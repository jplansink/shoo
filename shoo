#!/usr/bin/env bash
# Shoo - npm supply chain attack scanner
# https://github.com/jplansink/shoo
#
# Three-phase architecture: SCAN â†’ ANALYZE â†’ REPORT
# Detects: Shai-Hulud, nx/Singularity, debug/chalk, DuckDB, Unicode malware
#
# Usage:
#   ./shoo                    # Scan current directory + system
#   ./shoo ~/projects         # Scan specific directory + system
#   ./shoo --system           # System-only scan
#   ./shoo --help             # Show help

set -o pipefail

readonly VERSION="2.2.0"
readonly MALWARE_DB_URL="https://malware-list.aikido.dev/malware_predictions.json"
readonly OSV_API_URL="https://api.osv.dev/v1/query"
readonly CACHE_DIR="${HOME}/.cache/shoo"
readonly CACHE_TTL=86400  # 24 hours

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

VERBOSITY=1          # 0=quiet, 1=normal, 2=verbose, 3=debug
SCAN_PROJECTS=1      # 1=scan project dirs, 0=skip
SCAN_SYSTEM=0        # 1=scan system locations, 0=skip (use --system)
SEARCH_DIR=""        # Directory to scan
USE_ONLINE_DB=1      # 1=fetch online database, 0=offline only
OUTPUT_FORMAT="text" # text|json|sarif

# Colors (detect terminal support)
if [[ -t 1 ]] && command -v tput &>/dev/null && [[ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]]; then
    readonly RED='\033[0;31m'
    readonly YELLOW='\033[1;33m'
    readonly BLUE='\033[0;34m'
    readonly DIM='\033[2m'
    readonly NC='\033[0m'
else
    readonly RED='' YELLOW='' BLUE='' DIM='' NC=''
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA STRUCTURES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Findings array: stores all detections before filtering
declare -a FINDINGS=()

# Statistics
declare -i FILES_SCANNED=0
declare -i DIRS_SCANNED=0
declare -i CRITICAL_COUNT=0
declare -i HIGH_COUNT=0
declare -i MEDIUM_COUNT=0
declare -i LOW_COUNT=0


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SIGNATURES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Malware files
readonly -a MALWARE_FILES=(
    "setup_bun.js"
    "bun_environment.js"
    "actionsSecrets.json"
)

# Malicious UUIDs
readonly MALWARE_UUID="bb8ca5f6-4175-45d2-b042-fc9ebb8170b7"

# Exfiltration domains
readonly EXFIL_DOMAINS="webhook\.site|pastebin\.com|paste\.ee|hastebin\.com"

# Compromised package versions (format: "pkg@version|attack_name")
readonly BAD_VERSIONS="
nx@21.5.0|nx/Singularity
nx@20.9.0|nx/Singularity
nx@20.10.0|nx/Singularity
nx@21.6.0|nx/Singularity
nx@20.11.0|nx/Singularity
nx@20.12.0|nx/Singularity
nx@21.7.0|nx/Singularity
nx@21.8.0|nx/Singularity
debug@4.4.2|debug/chalk compromise
chalk@5.6.1|debug/chalk compromise
ansi-styles@6.2.2|debug/chalk compromise
color-name@2.0.1|debug/chalk compromise
strip-ansi@7.1.1|debug/chalk compromise
color@5.0.1|debug/chalk compromise
color-convert@3.1.1|debug/chalk compromise
color-string@2.1.1|debug/chalk compromise
has-ansi@6.0.1|debug/chalk compromise
ansi-regex@6.2.1|debug/chalk compromise
supports-color@10.2.1|debug/chalk compromise
backslash@0.2.1|debug/chalk compromise
wrap-ansi@9.0.1|debug/chalk compromise
is-arrayish@0.3.3|debug/chalk compromise
error-ex@1.3.3|debug/chalk compromise
slice-ansi@7.1.1|debug/chalk compromise
simple-swizzle@0.2.3|debug/chalk compromise
chalk-template@1.1.1|debug/chalk compromise
supports-hyperlinks@4.1.1|debug/chalk compromise
duckdb@1.3.3|DuckDB compromise
@duckdb/node-api@1.3.3|DuckDB compromise
@duckdb/node-bindings@1.3.3|DuckDB compromise
@duckdb/duckdb-wasm@1.29.2|DuckDB compromise
xrpl@4.2.4|XRP compromise
xrpl@4.2.3|XRP compromise
xrpl@4.2.2|XRP compromise
xrpl@4.2.1|XRP compromise
xrpl@2.14.2|XRP compromise
@react-native-aria/focus@0.2.10|React Native Aria compromise
@react-native-aria/utils@0.2.13|React Native Aria compromise
@react-native-aria/overlays@0.3.16|React Native Aria compromise
@react-native-aria/interactions@0.2.17|React Native Aria compromise
@react-native-aria/toggle@0.2.12|React Native Aria compromise
@react-native-aria/switch@0.2.5|React Native Aria compromise
@react-native-aria/checkbox@0.2.11|React Native Aria compromise
@react-native-aria/radio@0.2.14|React Native Aria compromise
@react-native-aria/button@0.2.11|React Native Aria compromise
@react-native-aria/menu@0.2.16|React Native Aria compromise
@react-native-aria/listbox@0.2.10|React Native Aria compromise
@react-native-aria/tabs@0.2.14|React Native Aria compromise
@react-native-aria/combobox@0.2.8|React Native Aria compromise
@react-native-aria/disclosure@0.2.9|React Native Aria compromise
@react-native-aria/slider@0.2.13|React Native Aria compromise
@react-native-aria/separator@0.2.7|React Native Aria compromise
@gluestack-ui/utils@0.1.16|React Native Aria compromise
@gluestack-ui/utils@0.1.17|React Native Aria compromise
posthog-js@1.297.3|Shai-Hulud 2.0
@postman/tunnel-agent@0.6.5|Shai-Hulud 2.0
@postman/tunnel-agent@0.6.6|Shai-Hulud 2.0
@postman/tunnel-agent@0.6.7|Shai-Hulud 2.0
@asyncapi/specs@6.8.2|Shai-Hulud 2.0
@asyncapi/specs@6.8.3|Shai-Hulud 2.0
@asyncapi/specs@6.9.1|Shai-Hulud 2.0
@asyncapi/specs@6.10.1|Shai-Hulud 2.0
@ensdomains/ensjs@4.0.3|Shai-Hulud 2.0
kill-port@2.0.2|Shai-Hulud 2.0
kill-port@2.0.3|Shai-Hulud 2.0
shell-exec@1.1.3|Shai-Hulud 2.0
shell-exec@1.1.4|Shai-Hulud 2.0
get-them-args@1.3.3|Shai-Hulud 2.0
"

# Targeted organizations (Shai-Hulud 2.0 targets)
readonly TARGETED_ORGS="@asyncapi|@posthog|posthog-js|posthog-node|@postman|@zapier|zapier-platform|@ensdomains|@react-native-aria|@gluestack-ui|@browserbase|@voiceflow|@accordproject"

# Secret patterns
readonly SECRET_AWS_KEY="AKIA[0-9A-Z]{16}"
readonly SECRET_GITHUB_TOKEN="ghp_[a-zA-Z0-9]{36}"
readonly SECRET_NPM_TOKEN="npm_[a-zA-Z0-9]{36}"
readonly SECRET_PRIVATE_KEY="-----BEGIN.*PRIVATE KEY-----"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CWE MAPPINGS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Map detector names to CWE IDs
get_cwe_for_detector() {
    case "$1" in
        shai_hulud|versions|unicode|workflow|vscode|cache|shell)
            echo "CWE-506" ;;
        postinstall)
            echo "CWE-94" ;;
        semver)
            echo "CWE-1104" ;;
        exfil)
            echo "CWE-200" ;;
        destructive)
            echo "CWE-912" ;;
        creds)
            echo "CWE-522" ;;
        secrets)
            echo "CWE-798" ;;
        npm_audit|osv)
            echo "CWE-1035" ;;
        obfuscation)
            echo "CWE-506" ;;
        *)
            echo "" ;;
    esac
}

# CWE URL helper
get_cwe_url() {
    local cwe="$1"
    [[ -z "$cwe" ]] && return
    local id="${cwe#CWE-}"
    echo "https://cwe.mitre.org/data/definitions/${id}.html"
}


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# UTILITY FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

log_debug() { [[ $VERBOSITY -ge 3 ]] && echo -e "${DIM}$1${NC}" >&2; }
log_info()  { [[ $VERBOSITY -ge 3 ]] && echo "$1" >&2; }
log_warn()  { [[ $VERBOSITY -ge 3 ]] && echo "$1" >&2; }
log_error() { echo "Error: $1" >&2; }

# Print header with scan target
print_header() {
    [[ $VERBOSITY -eq 0 ]] && return

    local target
    if [[ $SCAN_SYSTEM -eq 1 ]] && [[ $SCAN_PROJECTS -eq 0 ]]; then
        target="system"
    elif [[ -n "$SEARCH_DIR" ]]; then
        # Show relative path
        target="${SEARCH_DIR/#$PWD/.}"
        [[ "$target" == "$SEARCH_DIR" ]] && target="${SEARCH_DIR/#$HOME/~}"
    else
        target="."
    fi

    echo ""
    if [[ $VERBOSITY -ge 2 ]]; then
        echo -e "${BLUE}Shoo ğŸ‘»${NC} v${VERSION}"
    else
        echo -e "${BLUE}Shoo ğŸ‘»${NC} ${target}"
    fi
}

# Print verbose completion checkmark
print_check() {
    [[ $VERBOSITY -lt 2 ]] && return
    echo " âœ” $1"
}

clear_progress() {
    [[ $VERBOSITY -eq 0 ]] && return
    printf "\r%-70s\r" "" >&2
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FILE CLASSIFICATION (Context-Aware Detection)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Classify a file by its type/context
# Returns: typescript_definition, type_package, test_file, build_artifact,
#          package_cache, documentation, config, source, unknown
classify_file() {
    local file="$1"
    local basename="${file##*/}"
    local ext="${basename##*.}"
    local dir="${file%/*}"

    # TypeScript definitions (NEVER contain executable code)
    [[ "$basename" == *.d.ts ]] && echo "typescript_definition" && return

    # Type packages (@types/*)
    [[ "$dir" == */node_modules/@types/* ]] && echo "type_package" && return

    # Test files - require path component boundaries (not substring matches)
    [[ "$basename" =~ \.(test|spec|mock)\.(js|ts|jsx|tsx)$ ]] && echo "test_file" && return
    [[ "$dir" =~ (^|/)(__tests__|__mocks__|test|tests|spec|specs)(/|$) ]] && echo "test_file" && return

    # Build artifacts - require path component boundaries
    [[ "$dir" =~ (^|/)(dist|build|\.next|out|\.nuxt|\.output)(/|$) ]] && echo "build_artifact" && return

    # Sandbox/template/example contexts (expected destructive patterns)
    [[ "$dir" =~ (^|/)(sandbox|template|templates|example|examples|demo|demos|fixture|fixtures|sample|samples)(/|$) ]] && echo "sandbox" && return

    # Package manager caches
    [[ "$dir" =~ (^|/)(\.npm|\.yarn|\.pnpm|\.bun/install/cache)(/|$) ]] && echo "package_cache" && return

    # Documentation
    [[ "$ext" =~ ^(md|txt|rst|adoc)$ ]] && echo "documentation" && return

    # Config files
    [[ "$basename" =~ ^(\.|)(package|tsconfig|jsconfig|eslint|prettier|babel|webpack|vite|rollup) ]] && echo "config" && return

    # Source files
    [[ "$ext" =~ ^(js|ts|jsx|tsx|mjs|cjs)$ ]] && echo "source" && return

    echo "unknown"
}

# Check if file should be excluded from scanning
is_excluded() {
    local file="$1"
    local file_type="$2"

    # Always exclude type definitions from dangerous pattern checks
    [[ "$file_type" == "typescript_definition" ]] && return 0
    [[ "$file_type" == "type_package" ]] && return 0

    # Exclude documentation
    [[ "$file_type" == "documentation" ]] && return 0

    # Check .shooignore if exists (with null safety for SEARCH_DIR)
    if [[ -n "$SEARCH_DIR" ]] && [[ -f "${SEARCH_DIR}/.shooignore" ]]; then
        while IFS= read -r pattern; do
            [[ "$pattern" =~ ^# ]] && continue
            [[ -z "$pattern" ]] && continue
            [[ "$file" == *$pattern* ]] && return 0
        done < "${SEARCH_DIR}/.shooignore"
    fi

    return 1
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FINDINGS MANAGEMENT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Emit a finding
# Usage: emit_finding SEVERITY FILE MESSAGE [DETECTOR] [CONFIDENCE] [ADVICE]
emit_finding() {
    local severity="$1"
    local file="$2"
    local message="$3"
    local detector="${4:-unknown}"
    local confidence="${5:-0.9}"
    local advice="${6:-}"

    FINDINGS+=("${severity}|${file}|${message}|${detector}|${confidence}|${advice}")

    case "$severity" in
        CRITICAL) ((CRITICAL_COUNT++)) ;;
        HIGH)     ((HIGH_COUNT++)) ;;
        MEDIUM)   ((MEDIUM_COUNT++)) ;;
        LOW)      ((LOW_COUNT++)) ;;
    esac

    log_debug "Finding: $severity - $file - $message"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 1: SCAN
# Collect files and metadata. NO DECISIONS here.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•


scan_project_directory() {
    local dir="$1"
    ((DIRS_SCANNED++))

    # Find package.json files (project roots)
    while IFS= read -r pkg_json; do
        [[ -z "$pkg_json" ]] && continue
        local project_dir="${pkg_json%/package.json}"

        # Scan for malware files
        scan_for_malware_files "$project_dir"

        # Scan package.json
        scan_package_json "$pkg_json"

        # Scan lockfile if exists
        if [[ -f "$project_dir/package-lock.json" ]]; then
            scan_lockfile "$project_dir/package-lock.json"
            scan_osv_packages "$project_dir/package-lock.json"
        fi
        [[ -f "$project_dir/yarn.lock" ]] && scan_lockfile "$project_dir/yarn.lock"
        [[ -f "$project_dir/pnpm-lock.yaml" ]] && scan_lockfile "$project_dir/pnpm-lock.yaml"

        # Scan JS/TS files for suspicious patterns
        scan_source_files "$project_dir"

        # Scan GitHub workflows
        [[ -d "$project_dir/.github/workflows" ]] && scan_github_workflows "$project_dir/.github/workflows"

        # Run npm audit if available
        scan_npm_audit "$project_dir"

        ((FILES_SCANNED++))
    done < <(find "$dir" -name "package.json" -type f -not -path "*/node_modules/*" 2>/dev/null | head -500)
}

scan_for_malware_files() {
    local dir="$1"

    for malware_file in "${MALWARE_FILES[@]}"; do
        while IFS= read -r found; do
            [[ -z "$found" ]] && continue
            ((FILES_SCANNED++))
            # This is a definite malware file - mark for analysis
            echo "MALWARE_FILE|$found|$malware_file"
        done < <(find "$dir" -name "$malware_file" -type f 2>/dev/null)
    done
}

scan_package_json() {
    local file="$1"
    ((FILES_SCANNED++))

    # Check for targeted organizations
    if grep -qE "$TARGETED_ORGS" "$file" 2>/dev/null; then
        echo "TARGETED_ORG|$file"
    fi

    # Check for suspicious postinstall
    if grep -qE '"(pre|post)?install":\s*"[^"]*\b(curl|wget|eval|node\s+setup)\b' "$file" 2>/dev/null; then
        echo "SUSPICIOUS_POSTINSTALL|$file"
    fi

    # Check for unpinned risky packages
    if grep -qE "\"($TARGETED_ORGS)\":\s*\"[\^~]" "$file" 2>/dev/null; then
        echo "UNPINNED_RISKY|$file"
    fi
}

scan_lockfile() {
    local file="$1"
    local filename="${file##*/}"
    ((FILES_SCANNED++))

    # Check for known bad versions using format-specific detection
    while IFS='|' read -r pkg_version attack_name; do
        [[ -z "$pkg_version" ]] && continue
        # Use %@ to strip from last @ (handles scoped packages like @scope/pkg@ver)
        local pkg="${pkg_version%@*}"
        local ver="${pkg_version##*@}"
        local found=0

        case "$filename" in
            package-lock.json)
                # package-lock.json v2/v3: "node_modules/pkg": { "version": "x.y.z" }
                # Handles both regular and scoped packages
                # Use awk with state tracking (compatible with BSD/macOS awk)
                if awk -v pkg="$pkg" -v ver="$ver" 'BEGIN { current_pkg = "" }
                    /\"node_modules\// {
                        # Extract package name after node_modules/
                        gsub(/.*"node_modules\//, "")
                        gsub(/".*/, "")
                        current_pkg = $0
                    }
                    current_pkg == pkg && /\"version\"/ {
                        if (index($0, "\"" ver "\"") > 0) {
                            found = 1
                            exit
                        }
                    }
                    END { exit !found }
                ' "$file" 2>/dev/null; then
                    found=1
                fi
                ;;
            yarn.lock)
                # yarn.lock: pkg@version:\n  version "x.y.z"
                if awk -v pkg="$pkg" -v ver="$ver" '
                    index($0, pkg "@") == 1 || index($0, "\"" pkg "@") == 1 { in_block = 1; next }
                    /^[^ \t]/ { in_block = 0 }
                    in_block && /version / && index($0, "\"" ver "\"") > 0 {
                        found = 1
                        exit
                    }
                    END { exit !found }
                ' "$file" 2>/dev/null; then
                    found=1
                fi
                ;;
            pnpm-lock.yaml)
                # pnpm-lock.yaml: /pkg@version: or 'pkg@version':
                # Escape regex special chars in pkg/ver (handles @scope/pkg names)
                local pkg_escaped ver_escaped
                pkg_escaped=$(printf '%s' "$pkg" | sed 's/[[\.*^$/]/\\&/g')
                ver_escaped=$(printf '%s' "$ver" | sed 's/[[\.*^$/]/\\&/g')
                if grep -qE "(^|/)${pkg_escaped}@${ver_escaped}:" "$file" 2>/dev/null; then
                    found=1
                fi
                ;;
        esac

        [[ $found -eq 1 ]] && echo "BAD_VERSION|$file|$pkg_version|$attack_name"
    done <<< "$BAD_VERSIONS"
}

scan_source_files() {
    local dir="$1"

    while IFS= read -r file; do
        [[ -z "$file" ]] && continue
        ((FILES_SCANNED++))

        local file_type
        file_type=$(classify_file "$file")

        # Skip excluded file types
        is_excluded "$file" "$file_type" && continue

        # Check for exfiltration domains
        if grep -qE "$EXFIL_DOMAINS|$MALWARE_UUID" "$file" 2>/dev/null; then
            echo "EXFILTRATION|$file|$file_type"
        fi

        # Check for destructive patterns (context-aware)
        if grep -qE 'rm\s+-rf\s+[$/~]|rmSync.*recursive.*true' "$file" 2>/dev/null; then
            echo "DESTRUCTIVE|$file|$file_type"
        fi

        # Check for unicode malware pattern (requires multiple validators)
        # Pre-filter with single grep to avoid 3x file reads
        if grep -qE "0xFE00|0xE0100|codePointAt" "$file" 2>/dev/null; then
            # Verify all three patterns are present (confirms malware signature)
            if grep -q "0xFE00" "$file" 2>/dev/null && \
               grep -q "0xE0100" "$file" 2>/dev/null && \
               grep -q "codePointAt" "$file" 2>/dev/null; then
                echo "UNICODE_MALWARE|$file|$file_type"
            fi
        fi

        # Check for credential harvesting
        if grep -qiE "trufflehog|truffle.*hog" "$file" 2>/dev/null; then
            echo "CREDENTIAL_HARVEST|$file|$file_type"
        fi

        # Check for hardcoded secrets
        if grep -qE "$SECRET_AWS_KEY" "$file" 2>/dev/null; then
            echo "SECRET|$file|$file_type|aws_key"
        fi
        if grep -qE "$SECRET_GITHUB_TOKEN" "$file" 2>/dev/null; then
            echo "SECRET|$file|$file_type|github_token"
        fi
        if grep -qE "$SECRET_NPM_TOKEN" "$file" 2>/dev/null; then
            echo "SECRET|$file|$file_type|npm_token"
        fi
        if [[ "$file_type" == "source" ]] && grep -qE "$SECRET_PRIVATE_KEY" "$file" 2>/dev/null; then
            echo "SECRET|$file|$file_type|private_key"
        fi

        # Check for Base64 obfuscation (large encoded payloads)
        if [[ ! "$file" =~ \.(min|bundle)\.(js|mjs|cjs)$ ]]; then
            # Large Base64 strings in atob() or Buffer.from()
            if grep -qE 'atob\(["\x27][A-Za-z0-9+/=]{100,}["\x27]\)|Buffer\.from\(["\x27][A-Za-z0-9+/=]{100,}["\x27]' "$file" 2>/dev/null; then
                echo "OBFUSCATION|$file|$file_type|base64"
            # Hex-encoded strings (common in malware)
            elif grep -qE '(\\x[0-9a-fA-F]{2}){30,}' "$file" 2>/dev/null; then
                echo "OBFUSCATION|$file|$file_type|hex"
            # Long single lines without being a known minified file
            elif [[ "$file_type" == "source" ]] && awk 'length > 1000 && !/^[[:space:]]*(\/\/|\/?\*|#)/ { found=1; exit } END { exit !found }' "$file" 2>/dev/null; then
                echo "OBFUSCATION|$file|$file_type|minified"
            fi
        fi

    done < <(find "$dir" \( -name "*.js" -o -name "*.ts" -o -name "*.mjs" \) -type f -size -500k -not -path "*/node_modules/*" -not -path "*/dist/*" -not -path "*/.next/*" 2>/dev/null | head -2000)
}

scan_github_workflows() {
    local dir="$1"

    while IFS= read -r workflow; do
        [[ -z "$workflow" ]] && continue
        ((FILES_SCANNED++))

        # Check for shai-hulud workflows
        if [[ "${workflow##*/}" == *shai-hulud* ]] || [[ "${workflow##*/}" == formatter_* ]]; then
            echo "MALICIOUS_WORKFLOW|$workflow"
        fi

        # Check for SHA1HULUD runners
        if grep -qiE "SHA1HULUD|runs-on:.*self-hosted.*SHA1" "$workflow" 2>/dev/null; then
            echo "MALICIOUS_RUNNER|$workflow"
        fi

        # Check for suspicious base64
        if grep -qE "YmFzaC|L2Jpbi9iYXNo|bnBt" "$workflow" 2>/dev/null; then
            echo "SUSPICIOUS_WORKFLOW|$workflow"
        fi
    done < <(find "$dir" -name "*.yml" -o -name "*.yaml" 2>/dev/null)
}

scan_npm_audit() {
    local dir="$1"
    command -v npm &>/dev/null || return
    [[ ! -f "$dir/package.json" ]] && return
    [[ ! -f "$dir/package-lock.json" ]] && return

    local audit_output
    audit_output=$(cd "$dir" && npm audit --json 2>/dev/null || true)
    [[ -z "$audit_output" ]] && return

    # Parse npm audit JSON - extract vulnerabilities section
    echo "$audit_output" | awk -F'"' '
    /"vulnerabilities"[[:space:]]*:/ { in_vulns = 1 }
    /"metadata"/ { in_vulns = 0 }
    in_vulns && /"name"[[:space:]]*:/ { pkg = $4 }
    in_vulns && /"severity"[[:space:]]*:/ && pkg { sev = $4 }
    in_vulns && /"title"[[:space:]]*:/ && pkg && sev {
        title = $4
        shoo_sev = "MEDIUM"
        if (sev == "critical") shoo_sev = "CRITICAL"
        else if (sev == "high") shoo_sev = "HIGH"
        else if (sev == "moderate") shoo_sev = "MEDIUM"
        else if (sev == "low") shoo_sev = "LOW"
        print "NPM_AUDIT|" pkg "|" shoo_sev "|" title
        pkg = ""; sev = ""
    }
    '
}

# Query OSV.dev API for malware (MAL-* entries)
query_osv_malware() {
    local pkg="$1" ver="$2" lockfile="$3"
    [[ $USE_ONLINE_DB -eq 0 ]] && return
    command -v curl &>/dev/null || return

    local response
    response=$(curl -s --connect-timeout 2 --max-time 5 \
        -d "{\"version\":\"$ver\",\"package\":{\"name\":\"$pkg\",\"ecosystem\":\"npm\"}}" \
        "$OSV_API_URL" 2>/dev/null) || return

    # Check for MAL-* entries (malware, not regular CVEs)
    if echo "$response" | grep -q '"MAL-'; then
        local mal_id
        mal_id=$(echo "$response" | grep -o '"MAL-[0-9]*-[0-9]*"' | head -1 | tr -d '"')
        [[ -n "$mal_id" ]] && echo "OSV_MALWARE|$lockfile|$pkg@$ver|$mal_id"
    fi
}

# Scan lockfile packages against OSV.dev
scan_osv_packages() {
    local lockfile="$1"
    [[ $USE_ONLINE_DB -eq 0 ]] && return
    command -v curl &>/dev/null || return

    local filename="${lockfile##*/}"
    local -a checked_pkgs=()

    case "$filename" in
        package-lock.json)
            # Extract packages from package-lock.json v2/v3
            # shellcheck disable=SC2094
            while IFS= read -r line; do
                # Match "node_modules/pkgname": { ... "version": "x.y.z"
                if [[ "$line" =~ \"node_modules/([^\"]+)\" ]]; then
                    current_pkg="${BASH_REMATCH[1]}"
                elif [[ -n "$current_pkg" ]] && [[ "$line" =~ \"version\":[[:space:]]*\"([^\"]+)\" ]]; then
                    local ver="${BASH_REMATCH[1]}"
                    # Avoid duplicate checks
                    local pkg_ver="$current_pkg@$ver"
                    local already_checked=0
                    for checked in "${checked_pkgs[@]}"; do
                        [[ "$checked" == "$pkg_ver" ]] && already_checked=1 && break
                    done
                    if [[ $already_checked -eq 0 ]]; then
                        checked_pkgs+=("$pkg_ver")
                        # Only check top-level deps to limit API calls (first 50)
                        [[ ${#checked_pkgs[@]} -gt 50 ]] && break
                        query_osv_malware "$current_pkg" "$ver" "$lockfile"
                    fi
                    current_pkg=""
                fi
            done < "$lockfile"
            ;;
    esac
}

scan_system_locations() {
    # Global npm packages
    if command -v npm &>/dev/null; then
        local npm_global
        npm_global=$(npm list -g --depth=0 2>/dev/null || true)

        while IFS='|' read -r pkg_version attack_name; do
            [[ -z "$pkg_version" ]] && continue
            # Use %@ and ##@ to handle scoped packages (@scope/pkg@ver)
            if echo "$npm_global" | grep -q "${pkg_version%@*}@${pkg_version##*@}"; then
                echo "GLOBAL_BAD_VERSION|npm|$pkg_version|$attack_name"
            fi
        done <<< "$BAD_VERSIONS"
        ((FILES_SCANNED++))
    fi

    # VS Code extensions
    local vscode_dirs=(
        "$HOME/.vscode/extensions"
        "$HOME/.vscode-server/extensions"
        "$HOME/.vscodium/extensions"
    )

    for ext_dir in "${vscode_dirs[@]}"; do
        if [[ -d "$ext_dir" ]]; then
            while IFS= read -r jsfile; do
                [[ -z "$jsfile" ]] && continue
                ((FILES_SCANNED++))

                # Pre-filter with single grep to avoid 3x file reads
                if grep -qE "0xFE00|0xE0100|codePointAt" "$jsfile" 2>/dev/null; then
                    if grep -q "0xFE00" "$jsfile" 2>/dev/null && \
                       grep -q "0xE0100" "$jsfile" 2>/dev/null && \
                       grep -q "codePointAt" "$jsfile" 2>/dev/null; then
                        echo "VSCODE_MALWARE|$jsfile"
                    fi
                fi
            done < <(find "$ext_dir" -name "*.js" -type f -size -100k 2>/dev/null | head -500)
        fi
    done

    # npm cache
    local npm_cache
    npm_cache=$(npm config get cache 2>/dev/null || echo "$HOME/.npm")
    if [[ -d "$npm_cache" ]]; then
        for malware_file in "${MALWARE_FILES[@]}"; do
            if find "$npm_cache" -name "$malware_file" -type f 2>/dev/null | grep -q .; then
                echo "CACHE_MALWARE|$npm_cache|$malware_file"
            fi
        done
        ((FILES_SCANNED++))
    fi

    # Shell configs (nx malware tampered with these)
    for rcfile in "$HOME/.bashrc" "$HOME/.zshrc"; do
        if [[ -f "$rcfile" ]]; then
            ((FILES_SCANNED++))
            if grep -qE "shutdown|s1ngularity|singularity" "$rcfile" 2>/dev/null; then
                echo "SHELL_TAMPER|$rcfile"
            fi
        fi
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 2: ANALYZE
# Process scan results, apply context, calculate confidence. NO REPORTING.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

analyze_phase() {
    # Process each scan result
    while IFS='|' read -r type file extra1 extra2; do
        [[ -z "$type" ]] && continue

        case "$type" in
            MALWARE_FILE)
                emit_finding "CRITICAL" "$file" "Known malware file: $extra1" "shai_hulud" "1.0" \
                    "Delete immediately, rotate all credentials"
                ;;

            TARGETED_ORG)
                emit_finding "LOW" "$file" "Package from targeted organization" "shai_hulud" "0.3" \
                    "Verify package integrity if recently installed"
                ;;

            SUSPICIOUS_POSTINSTALL)
                emit_finding "HIGH" "$file" "Suspicious postinstall script (curl/wget/eval)" "postinstall" "0.85" \
                    "Review script contents before running npm install"
                ;;

            UNPINNED_RISKY)
                emit_finding "LOW" "$file" "Unpinned version of targeted package" "semver" "0.3" \
                    "Consider pinning exact versions"
                ;;

            BAD_VERSION)
                emit_finding "CRITICAL" "$file" "Compromised version: $extra1 ($extra2)" "versions" "1.0" \
                    "Remove package, clean reinstall, rotate credentials"
                ;;

            GLOBAL_BAD_VERSION)
                emit_finding "CRITICAL" "$file global" "Compromised global package: $extra1 ($extra2)" "versions" "1.0" \
                    "npm uninstall -g ${extra1%@*}, rotate credentials"
                ;;

            EXFILTRATION)
                local file_type="$extra1"
                if [[ "$file_type" == "test_file" ]]; then
                    emit_finding "LOW" "$file" "Exfiltration domain in test file" "exfil" "0.3" \
                        "Likely test mock - verify manually"
                else
                    emit_finding "HIGH" "$file" "Exfiltration endpoint detected" "exfil" "0.9" \
                        "Review file for data theft, check network logs"
                fi
                ;;

            DESTRUCTIVE)
                local file_type="$extra1"
                case "$file_type" in
                    test_file|sandbox)
                        emit_finding "LOW" "$file" "Destructive command in test/sandbox" "destructive" "0.2" ""
                        ;;
                    package_cache)
                        emit_finding "LOW" "$file" "Destructive pattern in cache (not executed)" "destructive" "0.3" \
                            "Run: npm cache clean --force"
                        ;;
                    source)
                        if grep -B8 -A8 "rm.*-rf\|rmSync" "$file" 2>/dev/null | grep -qiE "clean|teardown|reset|temp|tmp|cache|unlink|sandbox|template|example"; then
                            emit_finding "LOW" "$file" "Cleanup function detected" "destructive" "0.3" ""
                        elif [[ "$file" =~ (cleanup|teardown|reset|temp|cache|download|install|template|sandbox)\.(js|ts)$ ]]; then
                            emit_finding "LOW" "$file" "Likely cleanup in utility file" "destructive" "0.4" ""
                        else
                            emit_finding "HIGH" "$file" "Destructive payload" "destructive" "0.85" \
                                "Review file - may delete user data"
                        fi
                        ;;
                    *)
                        emit_finding "MEDIUM" "$file" "Destructive pattern (unknown context)" "destructive" "0.6" \
                            "Manual review recommended"
                        ;;
                esac
                ;;

            UNICODE_MALWARE)
                local file_type="$extra1"
                if [[ "$file_type" == "test_file" ]] || [[ "$file_type" == "package_cache" ]]; then
                    emit_finding "MEDIUM" "$file" "Unicode malware pattern (low-risk context)" "unicode" "0.5" \
                        "Verify file contents"
                else
                    emit_finding "HIGH" "$file" "Hidden unicode malware detected" "unicode" "0.9" \
                        "File contains invisible malicious code"
                fi
                ;;

            CREDENTIAL_HARVEST)
                emit_finding "HIGH" "$file" "Credential harvesting pattern" "creds" "0.8" \
                    "Check for unauthorized secret scanning"
                ;;

            SECRET)
                local file_type="$extra1"
                local secret_type="$extra2"
                local secret_name
                case "$secret_type" in
                    aws_key) secret_name="AWS access key" ;;
                    github_token) secret_name="GitHub token" ;;
                    npm_token) secret_name="npm token" ;;
                    private_key) secret_name="private key" ;;
                    *) secret_name="secret" ;;
                esac
                if [[ "$file_type" == "test_file" ]] || [[ "$file_type" == "sandbox" ]]; then
                    emit_finding "LOW" "$file" "Hardcoded $secret_name (test/example)" "secrets" "0.3" \
                        "Verify this is not a real credential"
                elif [[ "$file_type" == "config" ]] || [[ "$file_type" == "documentation" ]]; then
                    emit_finding "MEDIUM" "$file" "Hardcoded $secret_name in config/docs" "secrets" "0.5" \
                        "If real, rotate immediately"
                else
                    emit_finding "CRITICAL" "$file" "Hardcoded $secret_name detected" "secrets" "0.95" \
                        "Rotate credential, use environment variables"
                fi
                ;;

            OBFUSCATION)
                local file_type="$extra1"
                local obf_type="$extra2"
                local obf_name
                case "$obf_type" in
                    base64) obf_name="Large Base64-encoded payload" ;;
                    hex) obf_name="Hex-encoded payload" ;;
                    minified) obf_name="Suspicious minified code" ;;
                    *) obf_name="Obfuscated code" ;;
                esac
                if [[ "$file_type" == "test_file" ]] || [[ "$file_type" == "sandbox" ]]; then
                    emit_finding "LOW" "$file" "$obf_name (test/example)" "obfuscation" "0.3" \
                        "Likely test data - verify manually"
                else
                    emit_finding "HIGH" "$file" "$obf_name detected" "obfuscation" "0.8" \
                        "Review file for hidden malicious code"
                fi
                ;;

            OSV_MALWARE)
                local pkg="$extra1"
                local mal_id="$extra2"
                emit_finding "CRITICAL" "$file" "OSV malware: $pkg ($mal_id)" "osv" "1.0" \
                    "Remove package immediately, check osv.dev/$mal_id"
                ;;

            MALICIOUS_WORKFLOW)
                emit_finding "CRITICAL" "$file" "Known malicious GitHub workflow" "workflow" "1.0" \
                    "Delete workflow, check for unauthorized actions"
                ;;

            MALICIOUS_RUNNER)
                emit_finding "CRITICAL" "$file" "SHA1HULUD malicious runner" "workflow" "1.0" \
                    "Remove workflow, audit GitHub Actions history"
                ;;

            SUSPICIOUS_WORKFLOW)
                emit_finding "MEDIUM" "$file" "Suspicious base64 in workflow" "workflow" "0.6" \
                    "Review encoded content manually"
                ;;

            NPM_AUDIT)
                local pkg="$file"
                local npm_sev="$extra1"
                local title="$extra2"
                emit_finding "$npm_sev" "package.json" "npm audit: $title ($pkg)" "npm_audit" "0.9" \
                    "Run 'npm audit fix' or update $pkg"
                ;;

            VSCODE_MALWARE)
                emit_finding "HIGH" "$file" "Unicode malware in VS Code extension" "vscode" "0.9" \
                    "Uninstall extension, check VS Code marketplace"
                ;;

            CACHE_MALWARE)
                emit_finding "MEDIUM" "$file" "Malware file in npm cache: $extra1" "cache" "0.7" \
                    "Run: npm cache clean --force"
                ;;

            SHELL_TAMPER)
                emit_finding "CRITICAL" "$file" "Shell config tampering detected" "shell" "0.95" \
                    "Review and restore shell config, check for 'shutdown' commands"
                ;;
        esac
    done
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 3: REPORT
# Filter findings, format output, provide actionable advice.
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

json_escape() {
    printf '%s' "$1" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' | tr '\n' ' '
}

report_json() {
    local timestamp
    timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local scan_dir="${SEARCH_DIR:-$(pwd)}"
    local total=$((CRITICAL_COUNT + HIGH_COUNT + MEDIUM_COUNT + LOW_COUNT))

    echo "{"
    echo "  \"version\": \"$VERSION\","
    echo "  \"timestamp\": \"$timestamp\","
    echo "  \"scan\": {"
    echo "    \"directory\": \"$(json_escape "$scan_dir")\","
    echo "    \"files_scanned\": $FILES_SCANNED,"
    echo "    \"scan_system\": $([ $SCAN_SYSTEM -eq 1 ] && echo "true" || echo "false")"
    echo "  },"
    echo "  \"summary\": {"
    echo "    \"total\": $total,"
    echo "    \"critical\": $CRITICAL_COUNT,"
    echo "    \"high\": $HIGH_COUNT,"
    echo "    \"medium\": $MEDIUM_COUNT,"
    echo "    \"low\": $LOW_COUNT"
    echo "  },"
    echo "  \"findings\": ["

    local first=1
    for finding in "${FINDINGS[@]}"; do
        IFS='|' read -r severity file message detector confidence advice <<< "$finding"
        [[ -z "$severity" ]] && continue
        [[ $first -eq 0 ]] && echo ","
        first=0

        local cwe
        cwe=$(get_cwe_for_detector "$detector")
        local rel_file="$file"
        [[ "$file" == "$scan_dir"/* ]] && rel_file="${file#"$scan_dir"/}"

        echo -n "    {\"severity\": \"$severity\", \"file\": \"$(json_escape "$rel_file")\", \"message\": \"$(json_escape "$message")\", \"detector\": \"$detector\", \"confidence\": $confidence"
        [[ -n "$cwe" ]] && echo -n ", \"cwe\": \"$cwe\""
        [[ -n "$advice" ]] && echo -n ", \"advice\": \"$(json_escape "$advice")\""
        echo -n "}"
    done

    echo ""
    echo "  ]"
    echo "}"
}

severity_to_cvss() {
    case "$1" in
        CRITICAL) echo "9.0" ;;
        HIGH)     echo "7.0" ;;
        MEDIUM)   echo "5.0" ;;
        LOW)      echo "3.0" ;;
        *)        echo "5.0" ;;
    esac
}

report_sarif() {
    local scan_dir="${SEARCH_DIR:-$(pwd)}"

    cat << 'SARIF_HEADER'
{
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "version": "2.1.0",
  "runs": [{
    "tool": {
      "driver": {
SARIF_HEADER
    echo "        \"name\": \"Shoo\","
    echo "        \"version\": \"$VERSION\","
    echo "        \"informationUri\": \"https://github.com/jplansink/shoo\","
    echo "        \"rules\": []"
    echo "      }"
    echo "    },"
    echo "    \"results\": ["

    local first=1
    for finding in "${FINDINGS[@]}"; do
        IFS='|' read -r severity file message detector confidence advice <<< "$finding"
        [[ -z "$severity" ]] && continue

        [[ $first -eq 0 ]] && echo ","
        first=0

        local level="warning"
        [[ "$severity" == "CRITICAL" ]] && level="error"
        [[ "$severity" == "HIGH" ]] && level="error"
        [[ "$severity" == "LOW" ]] && level="note"

        local cwe
        cwe=$(get_cwe_for_detector "$detector")
        local cvss
        cvss=$(severity_to_cvss "$severity")

        # Make path relative
        local rel_file="$file"
        [[ "$file" == "$scan_dir"/* ]] && rel_file="${file#"$scan_dir"/}"

        echo "      {"
        echo "        \"ruleId\": \"shoo/$detector\","
        echo "        \"level\": \"$level\","
        echo "        \"message\": {\"text\": \"$(json_escape "$message")\"},"
        echo "        \"locations\": [{"
        echo "          \"physicalLocation\": {"
        echo "            \"artifactLocation\": {\"uri\": \"$(json_escape "$rel_file")\"}"
        echo "          }"
        echo "        }],"
        echo "        \"properties\": {"
        echo "          \"security-severity\": \"$cvss\""
        [[ -n "$cwe" ]] && echo "          ,\"tags\": [\"$cwe\"]"
        echo "        }"
        echo -n "      }"
    done

    echo ""
    echo "    ]"
    echo "  }]"
    echo "}"
}

report_phase() {
    [[ $VERBOSITY -eq 0 ]] && return

    # Build summary line
    local total=$((CRITICAL_COUNT + HIGH_COUNT + MEDIUM_COUNT + LOW_COUNT))
    local parts=()
    [[ $CRITICAL_COUNT -gt 0 ]] && parts+=("critical: $CRITICAL_COUNT")
    [[ $HIGH_COUNT -gt 0 ]] && parts+=("high: $HIGH_COUNT")
    [[ $MEDIUM_COUNT -gt 0 ]] && parts+=("medium: $MEDIUM_COUNT")
    [[ $LOW_COUNT -gt 0 ]] && parts+=("low: $LOW_COUNT")

    echo ""
    if [[ $total -eq 0 ]]; then
        echo "Total: 0 issues"
        return
    fi

    # Print summary first
    local summary=""
    local first=1
    for part in "${parts[@]}"; do
        if [[ $first -eq 1 ]]; then
            summary="$part"
            first=0
        else
            summary="$summary, $part"
        fi
    done
    echo "Total: $total ($summary)"
    echo ""

    # Group findings by severity
    local -a critical=() high=() medium=() low=()
    for finding in "${FINDINGS[@]}"; do
        IFS='|' read -r severity file message detector confidence advice <<< "$finding"
        case "$severity" in
            CRITICAL) critical+=("$finding") ;;
            HIGH)     high+=("$finding") ;;
            MEDIUM)   medium+=("$finding") ;;
            LOW)      low+=("$finding") ;;
        esac
    done

    # Helper to make path relative
    relative_path() {
        local file="$1"
        if [[ "$file" == "$SEARCH_DIR"/* ]]; then
            echo "${file#"$SEARCH_DIR"/}"
        elif [[ "$file" == "$HOME"/* ]]; then
            echo "${file/#"$HOME"/~}"
        else
            echo "$file"
        fi
    }

    # Helper to print a finding with inline URL
    print_finding() {
        local color="$1" symbol="$2" file="$3" message="$4" detector="$5" advice="$6"
        local cwe cwe_url
        cwe=$(get_cwe_for_detector "$detector")
        cwe_url=$(get_cwe_url "$cwe")

        if [[ -n "$cwe" ]]; then
            echo -e "  ${color}${symbol}${NC} $message ${DIM}[$cwe]${NC}"
        else
            echo -e "  ${color}${symbol}${NC} $message"
        fi
        echo "    $(relative_path "$file")"
        [[ -n "$cwe_url" ]] && echo -e "    ${DIM}$cwe_url${NC}"
        [[ -n "$advice" ]] && echo -e "    ${DIM}â†’ $advice${NC}"
    }

    # Report critical
    if [[ ${#critical[@]} -gt 0 ]]; then
        echo -e "${RED}CRITICAL${NC}"
        for finding in "${critical[@]}"; do
            IFS='|' read -r _ file message detector _ advice <<< "$finding"
            print_finding "$RED" "âœ—" "$file" "$message" "$detector" "$advice"
        done
        echo ""
    fi

    # Report high
    if [[ ${#high[@]} -gt 0 ]]; then
        echo -e "${YELLOW}HIGH${NC}"
        for finding in "${high[@]}"; do
            IFS='|' read -r _ file message detector _ advice <<< "$finding"
            print_finding "$YELLOW" "âœ—" "$file" "$message" "$detector" "$advice"
        done
        echo ""
    fi

    # Report medium
    if [[ ${#medium[@]} -gt 0 ]]; then
        echo -e "${BLUE}MEDIUM${NC}"
        for finding in "${medium[@]}"; do
            IFS='|' read -r _ file message detector _ advice <<< "$finding"
            print_finding "$BLUE" "?" "$file" "$message" "$detector" "$advice"
        done
        echo ""
    fi

    # Report low
    if [[ ${#low[@]} -gt 0 ]]; then
        echo -e "${DIM}LOW${NC}"
        for finding in "${low[@]}"; do
            IFS='|' read -r _ file message detector _ advice <<< "$finding"
            print_finding "$DIM" "-" "$file" "$message" "$detector" "$advice"
        done
        echo ""
    fi
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXTERNAL DATABASE (Optional)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

fetch_malware_database() {
    [[ $USE_ONLINE_DB -eq 0 ]] && return 1

    mkdir -p "$CACHE_DIR"
    local cache_file="$CACHE_DIR/malware.json"

    # Check cache freshness
    if [[ -f "$cache_file" ]]; then
        local age
        if [[ "$(uname)" == "Darwin" ]]; then
            age=$(($(date +%s) - $(stat -f %m "$cache_file")))
        else
            age=$(($(date +%s) - $(stat -c %Y "$cache_file")))
        fi

        if [[ $age -lt $CACHE_TTL ]]; then
            log_info "Using cached malware database (age: ${age}s)"
            return 0
        fi
    fi

    # Fetch fresh database
    log_info "Fetching malware database..."
    if command -v curl &>/dev/null; then
        curl -s --connect-timeout 5 --max-time 15 -o "$cache_file" "$MALWARE_DB_URL" 2>/dev/null && return 0
    elif command -v wget &>/dev/null; then
        wget -q --timeout=5 -O "$cache_file" "$MALWARE_DB_URL" 2>/dev/null && return 0
    fi

    log_warn "Could not fetch malware database - using hardcoded signatures"
    return 1
}

check_online_database() {
    local cache_file="$CACHE_DIR/malware.json"
    [[ ! -f "$cache_file" ]] && return

    # This would check packages against the online database
    # Implementation depends on database format
    log_info "Checked against online database"
}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

show_help() {
    cat << 'EOF'
Shoo ğŸ‘» npm supply chain scanner

Usage: shoo [options] [directory]

Options:
  -q, --quiet   Exit code only (for CI)
  --json        JSON output
  --sarif       SARIF output (GitHub Security tab)
  --all         Scan directory + system
  --system      System only (npm globals, VS Code, cache)
  --offline     Skip online databases

Exit codes:
  0  Clean
  1  Critical issues
  2  High issues
  3  Medium issues

Examples:
  shoo                Scan current directory
  shoo ~/projects     Scan specific directory
  shoo --all          Scan directory + system
  shoo --sarif        GitHub Actions integration
EOF
}

parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -q|--quiet)
                VERBOSITY=0
                shift
                ;;
            --all)
                SCAN_SYSTEM=1
                shift
                ;;
            --system)
                SCAN_PROJECTS=0
                SCAN_SYSTEM=1
                shift
                ;;
            --offline)
                USE_ONLINE_DB=0
                shift
                ;;
            --json)
                OUTPUT_FORMAT="json"
                VERBOSITY=0
                shift
                ;;
            --sarif)
                OUTPUT_FORMAT="sarif"
                VERBOSITY=0
                shift
                ;;
            --version)
                echo "shoo $VERSION"
                exit 0
                ;;
            --debug)
                VERBOSITY=3
                shift
                ;;
            -*)
                log_error "Unknown option: $1"
                exit 1
                ;;
            *)
                if [[ -d "$1" ]]; then
                    SEARCH_DIR="$(cd "$1" && pwd)"
                else
                    log_error "Directory not found: $1"
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Default to current directory if none specified
    [[ -z "$SEARCH_DIR" ]] && SEARCH_DIR="$(pwd)"
}

main() {
    parse_args "$@"
    print_header

    # Fetch online database (background, non-blocking)
    fetch_malware_database &
    local db_pid=$!

    # Phase 1: Scan (output to temp file to separate from progress messages)
    local scan_results
    scan_results=$(mktemp)
    trap 'rm -f "'"$scan_results"'"' EXIT

    # Scan project directory if enabled
    if [[ $SCAN_PROJECTS -eq 1 ]] && [[ -n "$SEARCH_DIR" ]]; then
        if [[ $VERBOSITY -ge 2 ]]; then
            echo ""
            echo "Scanning ${SEARCH_DIR/#$PWD/.}"
        fi
        scan_project_directory "$SEARCH_DIR" >> "$scan_results"
        print_check "project files"
    fi

    # Scan system locations if enabled
    if [[ $SCAN_SYSTEM -eq 1 ]]; then
        if [[ $VERBOSITY -ge 2 ]]; then
            echo ""
            echo "Scanning system"
        fi
        scan_system_locations >> "$scan_results"
        print_check "npm global packages"
        print_check "VS Code extensions"
        print_check "npm cache"
        print_check "shell configs"
    fi

    clear_progress
    [[ $VERBOSITY -ge 2 ]] && echo "Scanned $FILES_SCANNED files"

    # Wait for database fetch
    wait "$db_pid" 2>/dev/null || true

    # Phase 2: Analyze scan results
    analyze_phase < "$scan_results"

    # Check online database
    check_online_database

    # Phase 3: Report findings
    case "$OUTPUT_FORMAT" in
        json)  report_json ;;
        sarif) report_sarif ;;
        *)     report_phase ;;
    esac

    # Exit code based on severity
    [[ $CRITICAL_COUNT -gt 0 ]] && exit 1
    [[ $HIGH_COUNT -gt 0 ]] && exit 2
    [[ $MEDIUM_COUNT -gt 0 ]] && exit 3
    exit 0
}

main "$@"
